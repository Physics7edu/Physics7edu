<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <script src="https://www.glowscript.org/lib/jquery/2.1/jquery.min.js"></script>
  <script src="https://www.glowscript.org/lib/jquery/2.1/jquery-ui.custom.min.js"></script>
  <script src="https://www.glowscript.org/package/glow.3.2.min.js"></script>
  <script src="https://www.glowscript.org/package/RSrun.3.2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    html, body { margin:0; padding:0; height:100%; width:100%; background:#1f2937; color:#f3f4f6; font-family:'Inter',sans-serif; }
    body { display:flex; height:100vh; overflow:hidden; }
    #leftPane { width:22rem; padding:1.2rem; background:#111827; overflow-y:auto; display:flex; flex-direction:column; gap:1rem; }
    .control-group { background:#1f2937; padding:0.8rem; border-radius:0.5rem; box-shadow:0 0 6px rgba(0,0,0,0.3); }
    .control-group label { display:flex; justify-content:space-between; align-items:center; margin-bottom:0.3rem; font-weight:600; }
    .control-inputs { display:flex; gap:0.5rem; align-items:center; }
    input[type=range] { flex:1; }
    input[type=number] { width:4rem; color:black; padding:0.2rem; border-radius:0.3rem; }
    .button-group { display:flex; gap:0.5rem; flex-wrap:wrap; }
    .button-group button { flex:1; background:#6366f1; color:white; padding:0.4rem; border:none; border-radius:0.3rem; font-weight:600; }
    .button-group button:hover { background:#4f46e5; }
    .counters-container { display:grid; grid-template-columns:1fr; gap:0.6rem; margin-top:0.5rem; }
    .counter { background:linear-gradient(135deg,#1f2937,#374151); padding:0.6rem 0.8rem; border-radius:0.5rem; box-shadow:0 2px 6px rgba(0,0,0,.5); display:flex; justify-content:space-between; align-items:center; font-weight:600; font-size:1rem; }
    .counter span:last-child { font-weight:bold; color:#facc15; font-size:1.2rem; }
    #rightPane { flex:1; display:flex; flex-direction:row; height:100%; }
    #sceneHolder { flex:1; height:100%; display:flex; }
    #glowscript { flex:1; }
    #graphHolder { flex:1; display:flex; flex-direction:column; height:100%; }
    .graphBox { flex:1; border-top:1px solid #333; }
    #graphHolder canvas { width:100% !important; height:100% !important; }
    .note { font-size:.8rem; color:#cbd5e1; opacity:.9; }
  </style>
</head>
<body>
  <div id="leftPane">
    <h2 class="text-lg font-bold">Projectile Motion</h2>

    <div class="control-group">
      <label for="speedSlider">Projectile Speed (m/s)</label>
      <div class="control-inputs">
        <input type="range" id="speedSlider" min="0" max="100" step="1" value="100">
        <input type="number" id="speedInput" value="100" min="0" max="100" step="1">
      </div>
    </div>

    <div class="control-group">
      <label for="angleSlider">Launch Angle (°)</label>
      <div class="control-inputs">
        <input type="range" id="angleSlider" min="0" max="90" step="1" value="45">
        <input type="number" id="angleInput" value="45" min="0" max="90" step="1">
      </div>
    </div>

    <div class="control-group">
      <label for="timeSlider">Select Time (s) <span class="note" id="tofNote"></span></label>
      <div class="control-inputs">
        <input type="range" id="timeSlider" min="0" max="20" step="0.01" value="0">
        <input type="number" id="timeInput" value="0" min="0" max="20" step="0.01">
      </div>
    </div>

    <div class="button-group">
      <button id="btnPlay">Play</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
    </div>

    <div class="counters-container">
      <div class="counter"><span>Horizontal Velocity:</span><span id="counterVx">0.0</span></div>
      <div class="counter"><span>Vertical Velocity:</span><span id="counterVy">0.0</span></div>
      <div class="counter"><span>Angle w.r.t Horizontal:</span><span id="counterAngleH">0.0</span></div>
      <div class="counter"><span>Angle w.r.t Downward Vertical:</span><span id="counterAngleV">0.0</span></div>
      <div class="counter"><span>Max Horizontal Distance:</span><span id="counterMaxX">0.0</span></div>
      <div class="counter"><span>Max Vertical Height:</span><span id="counterMaxY">0.0</span></div>
    </div>
  </div>

  <div id="rightPane">
    <div id="sceneHolder"><div id="glowscript"></div></div>
    <div id="graphHolder">
      <div class="graphBox"><canvas id="velocityChart"></canvas></div>
      <div class="graphBox"><canvas id="angleChart"></canvas></div>
    </div>
  </div>

<script>
/* ------- constants for track labels -------- */
const TRACK_FONT_PX = 14;       // fixed font size (pixels) for axis labels
const V_TICK = 50;              // fixed vertical tick step (units)
const LEFT_MARGIN_FRAC = 0.10;  // left margin so vertical labels never clip
const CHART_X_MIN = 0, CHART_X_MAX = 20; // fixed x-axis range for both charts

/* ---------- Physics + State ---------- */
const g = 10, DT = 0.02; // meters, seconds
let speed = 100, angleDeg = 45;
let v0x=0, v0y=0, t=0, x=0, y=0, TOF=0, R=0, H=0;
let scene, ball, animTimer = null;
let velocityChart, angleChart;
let vxArrow, vyArrow, vArrow, hLine, vLine, hLabel, vLabel;

/* ---------- Helpers ---------- */
const toRad = d => d*Math.PI/180;
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
function niceStep(rangeTarget){
  const steps = [1,2,5,10,20,50,100,200,500,1000,2000,5000];
  for (const s of steps) if (rangeTarget/s <= 12) return s;
  return steps[steps.length-1];
}

/* ---------- Setup ---------- */
function computeParams(){
  const rad = toRad(angleDeg);
  v0x = speed*Math.cos(rad);
  v0y = speed*Math.sin(rad);
  TOF = v0y>0 ? (2*v0y/g) : 0;
  R   = (speed*speed*Math.sin(2*rad))/g;
  H   = (speed*speed*Math.sin(rad)*Math.sin(rad))/(2*g);

  // Update time inputs (graph axes are fixed 0..20 regardless)
  document.getElementById('timeSlider').max = CHART_X_MAX;
  document.getElementById('timeInput').max  = CHART_X_MAX;
  document.getElementById('tofNote').textContent = `(TOF ≈ ${TOF.toFixed(2)} s)`;
  document.getElementById('counterMaxX').textContent = R.toFixed(1);
  document.getElementById('counterMaxY').textContent = H.toFixed(1);
}

function initScene(){
  const container = document.getElementById("glowscript");
  container.innerHTML = "";
  if(typeof window.__context !== "undefined") delete window.__context;
  window.__context = { glowscript_container: container };

  computeParams();

  const YMAX = Math.ceil((H + 20) / V_TICK) * V_TICK;
  const leftMargin = LEFT_MARGIN_FRAC * Math.max(R, YMAX);

  scene = canvas({ width: container.clientWidth || 600, height: container.clientHeight || 400, background: color.black });
  scene.autoscale=false; scene.userzoom=false; scene.userspin=false;

  const cx = (R + leftMargin) / 2;
  const cy = YMAX / 2;
  scene.center = vec(cx, cy, 0);
  scene.range  = Math.max(cx, cy) * 1.2;

  drawTracks(YMAX, leftMargin);

  const base = Math.max(R+leftMargin, YMAX) || 100;
  ball = sphere({ pos: vec(0,0,0), radius: base/150, color: color.orange, make_trail:true });
  const shaft = base/300;
  vxArrow = arrow({ pos: ball.pos, axis: vec(v0x,0,0), color: color.red,   shaftwidth: shaft });
  vyArrow = arrow({ pos: ball.pos, axis: vec(0,v0y,0), color: color.green, shaftwidth: shaft });
  vArrow  = arrow({ pos: ball.pos, axis: vec(v0x,v0y,0), color: color.cyan, shaftwidth: shaft });

  hLine = curve({ pos:[ball.pos, vec(ball.pos.x,0,0)], color:color.white });
  vLine = curve({ pos:[ball.pos, vec(0,ball.pos.y,0)], color:color.white });

  hLabel = label({ pos:ball.pos, text:"", height:14, color:color.yellow, box:false, yoffset:12 });
  vLabel = label({ pos:ball.pos, text:"", height:14, color:color.yellow, box:false, xoffset:12 });
}

function drawTracks(YMAX, leftMargin){
  const origin = vec(0,0,0);
  const labelX = -leftMargin * 0.5;

  // Vertical axis
  curve({ pos:[origin, vec(0, YMAX, 0)], color: color.white, radius:0.05 });
  for(let yy=0; yy<=YMAX+1e-6; yy+=V_TICK){
    const tick = (yy % (5*V_TICK) === 0) ? 2 : 1;
    curve({ pos:[vec(-tick,yy,0), vec(0,yy,0)], color: color.white });
    label({ pos:vec(labelX,yy,0), text:String(yy), box:false, height:TRACK_FONT_PX, color:color.white });
  }

  // Horizontal axis
  const xStep = niceStep(R || 1);
  curve({ pos:[origin, vec(R, 0, 0)], color: color.white, radius:0.05 });
  for(let xx=0; xx<=R+1e-6; xx+=xStep){
    const tick = (xx % (5*xStep) === 0) ? 2 : 1;
    curve({ pos:[vec(xx,0,0), vec(xx,-tick,0)], color: color.white });
    label({ pos:vec(xx,-V_TICK*0.12,0), text:String(xx), box:false, height:TRACK_FONT_PX, color:color.white });
  }
}

function initCharts(){
  if(velocityChart) velocityChart.destroy();
  if(angleChart) angleChart.destroy();

  velocityChart = new Chart(document.getElementById('velocityChart'), {
    type:'line',
    data:{ datasets:[
      { label:'Horizontal Velocity (m/s)', data:[], borderColor:'red',   borderWidth:2, pointRadius:0 },
      { label:'Vertical Velocity (m/s)',   data:[], borderColor:'green', borderWidth:2, pointRadius:0 }
    ]},
    options:{
      responsive:true, maintainAspectRatio:false, animation:false,
      scales:{
        x:{ type:'linear', min: CHART_X_MIN, max: CHART_X_MAX,
            title:{display:true, text:'Time (s)', color:'#f3f4f6'}, ticks:{color:'#f3f4f6'} },
        y:{ title:{display:true, text:'Velocity (m/s)', color:'#f3f4f6'},
            min:-100, max:100, ticks:{color:'#f3f4f6'} }   /* <-- fixed -100..100 */
      },
      plugins:{ legend:{ labels:{ color:'#f3f4f6' } } }
    }
  });

  angleChart = new Chart(document.getElementById('angleChart'), {
    type:'line',
    data:{ datasets:[
      { label:'Angle w.r.t Downward Vertical (°)', data:[], borderColor:'orange', borderWidth:2, pointRadius:0 },
      { label:'Angle w.r.t Horizontal (°)',        data:[], borderColor:'cyan',   borderWidth:2, pointRadius:0 }
    ]},
    options:{
      responsive:true, maintainAspectRatio:false, animation:false,
      scales:{
        x:{ type:'linear', min: CHART_X_MIN, max: CHART_X_MAX,
            title:{display:true, text:'Time (s)', color:'#f3f4f6'}, ticks:{color:'#f3f4f6'} },
        y:{ title:{display:true, text:'Angle (°)', color:'#f3f4f6'}, min:0, max:90, ticks:{color:'#f3f4f6'} }
      },
      plugins:{ legend:{ labels:{ color:'#f3f4f6' } } }
    }
  });
}

/* ---------- UI/Counters ---------- */
function updatePerpendiculars(){
  hLine.modify(0, ball.pos);
  hLine.modify(1, vec(ball.pos.x,0,0));
  vLine.modify(0, ball.pos);
  vLine.modify(1, vec(0,ball.pos.y,0));
  hLabel.pos = ball.pos;
  vLabel.pos = ball.pos;
  hLabel.text = `${ball.pos.x.toFixed(1)}`;
  vLabel.text = `${ball.pos.y.toFixed(1)}`;
}

function updateCounters(angleH, angleV, vxVal, vyVal){
  document.getElementById('counterVx').textContent = vxVal.toFixed(1);
  document.getElementById('counterVy').textContent = vyVal.toFixed(1);
  document.getElementById('counterAngleH').textContent = angleH.toFixed(1);
  document.getElementById('counterAngleV').textContent = angleV.toFixed(1);
}

/* ---------- Closed-form state + clamped time ---------- */
function setStateFromTime(tSel){
  const tClamped = clamp(tSel, 0, TOF);
  t = Math.abs(tClamped - TOF) < 1e-6 ? TOF : tClamped;

  const vx = v0x;
  const vy = v0y - g*t;
  x = v0x * t;
  y = v0y * t - 0.5*g*t*t;

  ball.pos = vec(x, Math.max(0, y), 0);
  vxArrow.pos = vyArrow.pos = vArrow.pos = ball.pos;
  vxArrow.axis = vec(vx, 0, 0);
  vyArrow.axis = vec(0, vy, 0);
  vArrow.axis  = vec(vx, vy, 0);

  updatePerpendiculars();

  const angleH = Math.abs(Math.atan2(vy, vx) * 180/Math.PI);
  const angleV = Math.abs(Math.atan2(vx, Math.abs(vy)) * 180/Math.PI);
  updateCounters(angleH, angleV, vx, vy);
}

/* ---------- Animation loop ---------- */
function tick(){
  const tNext = t + DT;

  if (tNext >= TOF) {
    t = TOF;
    setStateFromTime(t);

    // final chart points
    velocityChart.data.datasets[0].data.push({ x: t, y: v0x });
    velocityChart.data.datasets[1].data.push({ x: t, y: -v0y });
    const angleH = Math.abs(Math.atan2(-v0y, v0x) * 180/Math.PI);
    const angleV = Math.abs(Math.atan2(v0x, Math.abs(-v0y)) * 180/Math.PI);
    angleChart.data.datasets[0].data.push({ x: t, y: angleV });
    angleChart.data.datasets[1].data.push({ x: t, y: angleH });
    velocityChart.update('none'); angleChart.update('none');

    clearInterval(animTimer); animTimer = null;
    return;
  }

  t = tNext;
  setStateFromTime(t);

  // stream points (charts keep fixed axes)
  const vy = v0y - g*t;
  const angleH = Math.abs(Math.atan2(vy, v0x) * 180/Math.PI);
  const angleV = Math.abs(Math.atan2(v0x, Math.abs(vy)) * 180/Math.PI);
  velocityChart.data.datasets[0].data.push({ x: t, y: v0x });
  velocityChart.data.datasets[1].data.push({ x: t, y: vy });
  angleChart.data.datasets[0].data.push({ x: t, y: angleV });
  angleChart.data.datasets[1].data.push({ x: t, y: angleH });
  velocityChart.update('none'); angleChart.update('none');
}

/* ---------- Wiring ---------- */
function reset(){
  if(animTimer) { clearInterval(animTimer); animTimer = null; }
  x=0; y=0; t=0;
  initScene();
  initCharts();
  // start with empty charts and time inputs at 0..20
  velocityChart.data.datasets.forEach(d=>d.data=[]);
  angleChart.data.datasets.forEach(d=>d.data=[]);
  document.getElementById('timeSlider').value = "0";
  document.getElementById('timeInput').value  = "0";
  setStateFromTime(0);
}

document.getElementById('speedSlider').oninput = e=>{
  speed = Math.min(100, parseFloat(e.target.value)||0);
  document.getElementById('speedInput').value = speed;
  reset();
};
document.getElementById('speedInput').oninput = e=>{
  speed = Math.min(100, parseFloat(e.target.value)||0);
  document.getElementById('speedSlider').value = speed;
  reset();
};
document.getElementById('angleSlider').oninput = e=>{
  angleDeg = parseFloat(e.target.value)||0;
  document.getElementById('angleInput').value = angleDeg;
  reset();
};
document.getElementById('angleInput').oninput = e=>{
  angleDeg = parseFloat(e.target.value)||0;
  document.getElementById('angleSlider').value = angleDeg;
  reset();
};

// time scrubbing (still clamp to TOF, but inputs show 0..20)
document.getElementById('timeSlider').oninput = e=>{
  const ts = parseFloat(e.target.value)||0;
  document.getElementById('timeInput').value = ts.toFixed(2);
  setStateFromTime(ts);
};
document.getElementById('timeInput').oninput = e=>{
  const ts = parseFloat(e.target.value)||0;
  document.getElementById('timeSlider').value = ts;
  setStateFromTime(ts);
};

document.getElementById('btnPlay').onclick = ()=>{
  computeParams();
  if(animTimer) clearInterval(animTimer);
  // clear data so plots reload cleanly
  velocityChart.data.datasets.forEach(d=>d.data=[]);
  angleChart.data.datasets.forEach(d=>d.data=[]);
  t=0; x=0; y=0; setStateFromTime(0);
  animTimer = setInterval(tick, 20);
};
document.getElementById('btnPause').onclick = ()=>{ if(animTimer){ clearInterval(animTimer); animTimer=null; } };
document.getElementById('btnReset').onclick = reset;

$(document).ready(()=>{ reset(); });
</script>
</body>
</html>
